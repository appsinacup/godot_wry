#!/usr/bin/env python
from misc.utility.scons_hints import *

import os
import urllib.request
import zipfile
import time

Import("env")
Import("env_modules")


# region GitHub Release Downloader
def get_platform_target():
    """Get the platform target for the GitHub release."""
    platform_name = env["platform"]
    if platform_name == "linuxbsd":
        return "linux_x86_64"
    elif platform_name == "windows":
        arch = env["arch"]
        if arch == "x86_64":
            return "windows_x86_64"
        elif arch == "x86_32":
            return "windows_x86_32"
        elif arch == "arm64":
            return "windows_arm64"
    elif platform_name == "macos":
        arch = env["arch"]
        if arch == "x86_64":
            return "macos_x86_64"
        elif arch == "arm64":
            return "macos_arm64"
    print(f"Unsupported platform or architecture: {platform_name} {env['arch']}")
    return None


def download_and_extract_release():
    """Download the GitHub release and extract static libraries."""
    platform_target = get_platform_target()
    if not platform_target:
        raise RuntimeError(f"Unsupported platform: {env['platform']}")

    # GitHub release info
    repo = "appsinacup/godot_wry"
    release_url = f"https://api.github.com/repos/{repo}/releases/latest"

    # Create libs directory
    libs_dir = "libs"
    os.makedirs(libs_dir, exist_ok=True)

    # Check if we already have the libraries
    static_lib_path = f"{libs_dir}/libgodot_wry.a"
    if env["platform"] == "windows":
        static_lib_path = f"{libs_dir}/godot_wry.lib"

    # Always delete and redownload the library for now
    if os.path.exists(static_lib_path):
        print(f"Deleting existing static library: {static_lib_path}")
        os.remove(static_lib_path)

    try:
        print(f"Downloading godot_wry static libraries for {platform_target}...")

        # Get latest release info with authentication if available
        request = urllib.request.Request(release_url)
        
        # Add GitHub token if available (for CI/CD) - try multiple possible names
        github_token = (
            os.environ.get('GITHUB_TOKEN') or 
            os.environ.get('GH_TOKEN') or 
            os.environ.get('GITHUB_ACCESS_TOKEN') or
            os.environ.get('GH_ACCESS_TOKEN') or
            os.environ.get('GODOT_WRY_GITHUB_TOKEN')  # Custom fallback
        )
        
        # Debug: Check all environment variables related to GitHub
        print(f"DEBUG: GITHUB_TOKEN present: {'Yes' if github_token else 'No'}")
        print(f"DEBUG: GITHUB_ACTIONS: {os.environ.get('GITHUB_ACTIONS', 'Not set')}")
        print(f"DEBUG: CI: {os.environ.get('CI', 'Not set')}")
        print(f"DEBUG: Available env vars starting with GITHUB_: {[k for k in os.environ.keys() if k.startswith('GITHUB_')]}")
        
        if github_token:
            request.add_header('Authorization', f'token {github_token}')
            print("Using GitHub token for authentication")
        else:
            print("No GitHub token found - using unauthenticated requests (may hit rate limits)")
        
        # Retry logic for rate limiting
        max_retries = 3
        for attempt in range(max_retries):
            try:
                with urllib.request.urlopen(request) as response:
                    import json
                    release_data = json.loads(response.read().decode())
                break  # Success, exit retry loop
            except urllib.error.HTTPError as e:
                if e.code == 403 and "rate limit" in str(e).lower() and attempt < max_retries - 1:
                    wait_time = (attempt + 1) * 10  # Wait 10, 20, 30 seconds
                    print(f"Rate limit hit, waiting {wait_time} seconds before retry {attempt + 2}/{max_retries}...")
                    time.sleep(wait_time)
                    continue
                else:
                    raise  # Re-raise if not rate limit or final attempt

        # Find the static libraries archive
        download_url = None
        for asset in release_data.get("assets", []):
            if asset["name"] == "godot_wry_static_libraries.zip":
                download_url = asset["browser_download_url"]
                break

        if not download_url:
            raise RuntimeError("Could not find static libraries archive in release")

        # Download the archive
        archive_path = f"{libs_dir}/static_libs.zip"
        urllib.request.urlretrieve(download_url, archive_path)

        # Extract the appropriate platform libraries
        with zipfile.ZipFile(archive_path, "r") as zip_ref:
            # List all files in archive
            for file_info in zip_ref.filelist:
                file_path = file_info.filename

                # Check if this file is for our platform
                platform_match = False
                if platform_target == "linux_x86_64" and "x86_64-unknown-linux-gnu" in file_path:
                    platform_match = True
                elif platform_target == "windows_x86_64" and "x86_64-pc-windows-msvc" in file_path:
                    platform_match = True
                elif platform_target == "windows_x86_32" and "i686-pc-windows-msvc" in file_path:
                    platform_match = True
                elif platform_target == "windows_arm64" and "aarch64-pc-windows-msvc" in file_path:
                    platform_match = True
                elif platform_target == "macos_x86_64" and "x86_64-apple-darwin" in file_path:
                    platform_match = True
                elif platform_target == "macos_arm64" and "aarch64-apple-darwin" in file_path:
                    platform_match = True

                if platform_match and (file_path.endswith(".a") or file_path.endswith(".lib")):
                    # Extract the static library
                    zip_ref.extract(file_info, libs_dir)
                    # Move to root of libs directory
                    extracted_path = os.path.join(libs_dir, file_path)
                    final_path = os.path.join(libs_dir, os.path.basename(file_path))
                    if extracted_path != final_path:
                        os.rename(extracted_path, final_path)
                    print(f"Extracted: {os.path.basename(file_path)}")

        # Clean up
        os.remove(archive_path)

        # Remove any empty directories
        for root, dirs, files in os.walk(libs_dir, topdown=False):
            for dir_name in dirs:
                dir_path = os.path.join(root, dir_name)
                if not os.listdir(dir_path):
                    os.rmdir(dir_path)

        print("Download and extraction completed successfully!")

    except Exception as e:
        print(f"Failed to download godot_wry libraries: {e}")
        raise RuntimeError(f"Could not download godot_wry static libraries for {platform_target}: {e}")


# endregion

# Download the static libraries
try:
    download_and_extract_release()
except RuntimeError as e:
    print(f"Error: {e}")
    print("You may need to manually place the static libraries in modules/godot_wry/libs/")
    raise  # Re-raise to fail the build

# Setup environment
env_godot_wry = env_modules.Clone()

# Add include paths
env_godot_wry.Append(CPPPATH=["modules/godot_wry"])

# Link static libraries
libs_dir = "libs"
if env["platform"] == "linuxbsd":
    static_lib = f"{libs_dir}/libgodot_wry.a"
    if os.path.exists(static_lib):
        env.Append(LIBS=[env.File(f"{static_lib}")])
        print(f"Added static library: {static_lib}")
    else:
        print(f"Warning: Static library not found: {static_lib}")

elif env["platform"] == "windows":
    static_lib = f"{libs_dir}/godot_wry.lib"
    if os.path.exists(static_lib):
        env.Append(LIBS=[env.File(f"{static_lib}")])
        print(f"Added static library: {static_lib}")
    else:
        print(f"Warning: Static library not found: {static_lib}")

elif env["platform"] in ["macos", "osx"]:
    static_lib = f"{libs_dir}/libgodot_wry.a"
    if os.path.exists(static_lib):
        env.Append(LIBS=[env.File(f"{static_lib}")])
        print(f"Added static library: {static_lib}")
    else:
        print(f"Warning: Static library not found: {static_lib}")

if env["platform"] == "linuxbsd":
    # Linux dependencies for WRY
    #env.ParseConfig("pkg-config --cflags --libs gtk+-3.0")
    #env.ParseConfig("pkg-config --cflags --libs webkit2gtk-4.1")
    pass

elif env["platform"] == "windows":
    pass

elif env["platform"] in ["macos"]:
    # macOS dependencies for WRY
    env.Append(
        LINKFLAGS=[
            "-framework",
            "Cocoa",
            "-framework",
            "WebKit",
            "-framework",
            "CoreServices",
            "-framework",
            "Security",
        ]
    )

# Add source files
env.add_source_files(env.modules_sources, "register_types.cpp")
