#!/usr/bin/env python
from misc.utility.scons_hints import *

import os
import urllib.request
import zipfile
import json

Import("env")
Import("env_modules")


# region GitHub Release Downloader
def get_platform_target():
    """Get the platform target for the GitHub release."""
    platform_name = env["platform"]
    if platform_name == "linuxbsd":
        return "linux_x86_64"
    elif platform_name == "windows":
        arch = env["arch"]
        if arch == "x86_64":
            return "windows_x86_64"
        elif arch == "x86_32":
            return "windows_x86_32"
        elif arch == "arm64":
            return "windows_arm64"
    elif platform_name == "macos":
        arch = env["arch"]
        if arch == "x86_64":
            return "macos_x86_64"
        elif arch == "arm64":
            return "macos_arm64"
    print(f"Unsupported platform or architecture: {platform_name} {env['arch']}")
    return None


def download_and_extract_release():
    """Download the GitHub release and extract static libraries."""
    platform_target = get_platform_target()
    if not platform_target:
        raise RuntimeError(f"Unsupported platform: {env['platform']}")

    # GitHub release info
    repo = "appsinacup/godot_wry"
    release_url = f"https://api.github.com/repos/{repo}/releases/latest"

    # Create libs directory
    libs_dir = "libs"
    os.makedirs(libs_dir, exist_ok=True)

    # Check if we already have the libraries - determine correct file based on toolchain
    if env["platform"] == "windows":
        if env.get("use_mingw", False):
            static_lib_path = f"{libs_dir}/libgodot_wry.a"  # MinGW uses .a files
        else:
            static_lib_path = f"{libs_dir}/godot_wry.lib"   # MSVC/LLVM use .lib files
    else:
        static_lib_path = f"{libs_dir}/libgodot_wry.a"

    # Check if GitHub token is available for authenticated requests
    github_token = os.environ.get('GH_TOKEN')
    
    # If library exists and no GH_TOKEN, skip download
    if os.path.exists(static_lib_path) and not github_token:
        print(f"Static library already exists: {static_lib_path}")
        print("Skipping download (no GH_TOKEN available)")
        return
    
    # If GH_TOKEN is set, always delete and redownload for latest version
    if os.path.exists(static_lib_path) and github_token:
        print(f"Deleting existing static library: {static_lib_path}")
        os.remove(static_lib_path)

    try:
        print(f"Downloading godot_wry static libraries for {platform_target}...")

        # Get latest release info
        request = urllib.request.Request(release_url)
        
        # Add GitHub token if available
        if github_token:
            request.add_header('Authorization', f'token {github_token}')
            print("Using GitHub token for authentication")
        else:
            print("No GitHub token found - using unauthenticated requests")
        
        with urllib.request.urlopen(request) as response:
            release_data = json.loads(response.read().decode())

        # Find the static libraries archive
        download_url = None
        for asset in release_data.get("assets", []):
            if asset["name"] == "godot_wry_static_libraries.zip":
                download_url = asset["browser_download_url"]
                break

        if not download_url:
            raise RuntimeError("Could not find static libraries archive in release")

        # Download the archive
        archive_path = f"{libs_dir}/static_libs.zip"
        urllib.request.urlretrieve(download_url, archive_path)

        # Extract the appropriate platform libraries
        with zipfile.ZipFile(archive_path, "r") as zip_ref:
            # List all files in archive
            for file_info in zip_ref.filelist:
                file_path = file_info.filename

                # Check if this file is for our platform
                platform_match = False
                if platform_target == "linux_x86_64" and "x86_64-unknown-linux-gnu" in file_path:
                    platform_match = True
                elif platform_target == "windows_x86_64":
                    if env.get("use_mingw", False) and "x86_64-pc-windows-gnu" in file_path:
                        platform_match = True
                    elif not env.get("use_mingw", False) and "x86_64-pc-windows-msvc" in file_path:
                        platform_match = True
                elif platform_target == "windows_x86_32":
                    # MinGW x32 not supported - only MSVC
                    if "i686-pc-windows-msvc" in file_path:
                        platform_match = True
                elif platform_target == "windows_arm64":
                    # MinGW ARM64 not supported - only MSVC
                    if "aarch64-pc-windows-msvc" in file_path:
                        platform_match = True
                elif platform_target == "macos_x86_64" and "x86_64-apple-darwin" in file_path:
                    platform_match = True
                elif platform_target == "macos_arm64" and "aarch64-apple-darwin" in file_path:
                    platform_match = True

                if platform_match and (file_path.endswith(".a") or file_path.endswith(".lib")):
                    # Extract the static library
                    zip_ref.extract(file_info, libs_dir)
                    # Move to root of libs directory
                    extracted_path = os.path.join(libs_dir, file_path)
                    final_path = os.path.join(libs_dir, os.path.basename(file_path))
                    if extracted_path != final_path:
                        os.rename(extracted_path, final_path)
                    print(f"Extracted: {os.path.basename(file_path)}")

        # Clean up
        os.remove(archive_path)

        # Remove any empty directories
        for root, dirs, files in os.walk(libs_dir, topdown=False):
            for dir_name in dirs:
                dir_path = os.path.join(root, dir_name)
                if not os.listdir(dir_path):
                    os.rmdir(dir_path)

        print("Download and extraction completed successfully!")

    except Exception as e:
        print(f"Failed to download godot_wry libraries: {e}")
        raise RuntimeError(f"Could not download godot_wry static libraries for {platform_target}: {e}")


# endregion

# Download the static libraries
try:
    download_and_extract_release()
except RuntimeError as e:
    print(f"Error: {e}")
    print("You may need to manually place the static libraries in modules/godot_wry/libs/")
    raise  # Re-raise to fail the build

# Setup environment
env_godot_wry = env_modules.Clone()

# Add include paths
env_godot_wry.Append(CPPPATH=["modules/godot_wry"])

# Link static libraries
libs_dir = "libs"
if env["platform"] == "linuxbsd":
    static_lib = f"{libs_dir}/libgodot_wry.a"
    if os.path.exists(static_lib):
        env.Append(LIBS=[env.File(f"{static_lib}")])
        print(f"Added static library: {static_lib}")
    else:
        print(f"Warning: Static library not found: {static_lib}")

elif env["platform"] == "windows":
    # Use different library formats based on toolchain
    if env.get("use_mingw", False):
        static_lib = f"{libs_dir}/libgodot_wry.a"  # MinGW uses .a files
    else:
        static_lib = f"{libs_dir}/godot_wry.lib"   # MSVC/LLVM use .lib files
    
    if os.path.exists(static_lib):
        env.Append(LIBS=[env.File(f"{static_lib}")])
        print(f"Added static library: {static_lib}")
    else:
        print(f"Warning: Static library not found: {static_lib}")

elif env["platform"] in ["macos", "osx"]:
    static_lib = f"{libs_dir}/libgodot_wry.a"
    if os.path.exists(static_lib):
        env.Append(LIBS=[env.File(f"{static_lib}")])
        print(f"Added static library: {static_lib}")
    else:
        print(f"Warning: Static library not found: {static_lib}")

if env["platform"] == "linuxbsd":
    # Linux dependencies for WRY
    # Check if WebKit2GTK is installed, if not, try to install it
    import subprocess
    try:
        # Check if pkg-config can find webkit2gtk-4.1
        subprocess.check_output(["pkg-config", "--exists", "webkit2gtk-4.1"], stderr=subprocess.STDOUT)
        print("WebKit2GTK-4.1 found")
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("WebKit2GTK-4.1 not found, attempting to install...")
        try:
            # Try to install the required packages
            subprocess.run(["sudo", "apt", "update"], check=True)
            subprocess.run(["sudo", "apt", "install", "-y", "libwebkit2gtk-4.1-dev"], check=True)
            print("Successfully installed WebKit2GTK dependencies")
        except subprocess.CalledProcessError as e:
            print(f"Failed to install dependencies: {e}")
            print("Please manually install: sudo apt install libwebkit2gtk-4.1-dev")
            raise RuntimeError("Required Linux dependencies not available")
    
    env.ParseConfig("pkg-config --cflags --libs gtk+-3.0")
    env.ParseConfig("pkg-config --cflags --libs webkit2gtk-4.1")
    # Add linker flags to handle duplicate symbols from Rust libraries
    env.Append(LINKFLAGS=["-Wl,--allow-multiple-definition"])
    print("Added Linux linker flags to allow multiple symbol definitions")

elif env["platform"] == "windows":
    # Add linker flags to handle duplicate symbols from Rust libraries
    # First, remove any existing /WX flag that might be causing warnings to be treated as errors
    if "/WX" in env.get("LINKFLAGS", []):
        env["LINKFLAGS"].remove("/WX")
        print("Removed /WX flag from LINKFLAGS to prevent warnings as errors")
    
    if env.get("use_llvm", False):
        # LLVM linker (lld-link) - uses different syntax than MSVC linker
        env.Append(LINKFLAGS=["/FORCE:MULTIPLE"])
        print("Added Windows LLVM linker flags to allow multiple symbol definitions")
    elif env.get("use_mingw", False):
        # MinGW linker (GNU ld)
        env.Append(LINKFLAGS=["-Wl,--allow-multiple-definition"])
        print("Added Windows MinGW linker flags to allow multiple symbol definitions")
        
        # Add Windows system libraries required for WebView2 functionality (MinGW only)
        webview2_libs = [
            "advapi32",     # Registry functions (RegGetString, etc.)
            "ole32",        # COM functionality
            "oleaut32",     # OLE Automation
            "user32",       # Windows user interface
            "shell32",      # Shell functions
            "shlwapi",      # Shell light-weight utility functions
            "version",      # Version information functions
            "wininet",      # Internet functions
            "urlmon",       # URL moniker functions
            "comctl32",     # Common controls
        ]
        env.Append(LIBS=webview2_libs)
        print("Added Windows system libraries for MinGW build")
    else:
        # MSVC linker (link.exe)
        env.Append(LINKFLAGS=["/FORCE:MULTIPLE", "/ignore:4006", "/ignore:4088", "/WX-"])
        print("Added Windows MSVC linker flags to allow multiple symbol definitions and disable warnings as errors")

elif env["platform"] in ["macos"]:
    # macOS dependencies for WRY
    env.Append(
        LINKFLAGS=[
            "-framework",
            "Cocoa",
            "-framework",
            "WebKit",
            "-framework",
            "CoreServices",
            "-framework",
            "Security",
        ]
    )

# Add source files
env.add_source_files(env.modules_sources, "register_types.cpp")
